# /home/ubuntu/cryptography_project/crypto_lib/elgamal_signature.py

"""ElGamal Signature Scheme Implementation using PyCryptodome for number theory."""

import os
import secrets  # For cryptographically secure random numbers
from typing import Tuple, NamedTuple

from Crypto.Util import number
from Crypto.Hash import SHA256

# Define named tuples for clarity
class ElGamalParams(NamedTuple):
    p: int  # Large safe prime
    g: int  # Generator

class ElGamalPrivateKey(NamedTuple):
    params: ElGamalParams
    x: int  # Private key (1 <= x < p-1)

class ElGamalPublicKey(NamedTuple):
    params: ElGamalParams
    y: int  # Public key (y = g^x mod p)

class ElGamalSignature(NamedTuple):
    r: int
    s: int

def generate_elgamal_params(key_size: int = 2048) -> ElGamalParams:
    """Generates parameters (p, g) for the ElGamal signature scheme.

    Args:
        key_size: The desired bit length for the prime p. Recommended >= 2048.

    Returns:
        An ElGamalParams object containing the prime p and generator g.

    Raises:
        ValueError: If key_size is too small.
    """
    if key_size < 1024:
        # While 1024 might work, 2048 is generally recommended for security.
        raise ValueError("Key size should be at least 1024 bits, 2048 recommended.")

    # 1. Generate a large safe prime p (p = 2q + 1, where q is also prime)
    #    Using a safe prime simplifies finding a generator.
    print(f"Generating {key_size}-bit safe prime p...")
    # Using number.getStrongPrime ensures p=2q+1 where q is prime (safe prime)
    # However, getPrime is often faster and sufficient if we find g correctly.
    # Let's stick to getPrime and find g for the subgroup of order q.
    p = number.getPrime(key_size, randfunc=os.urandom)
    q = (p - 1) // 2
    # Check if q is prime. If not, generate a new p.
    # This check is important if not using getStrongPrime.
    while not number.isPrime(q):
        print(f"q={q} is not prime, regenerating p...")
        p = number.getPrime(key_size, randfunc=os.urandom)
        q = (p - 1) // 2

    print(f"Generated prime p (bit length {p.bit_length()}) with prime q = (p-1)/2")

    # 2. Find a generator g of the subgroup of order q.
    #    Find h such that h^((p-1)/q) mod p != 1. Then g = h^((p-1)/q) mod p.
    #    Since q = (p-1)/2, we need h^2 mod p != 1. Then g = h^2 mod p.
    #    g will have order q.
    while True:
        h = number.getRandomRange(2, p - 1, randfunc=os.urandom)
        g = pow(h, 2, p)
        # Ensure g is not 1 and g^q mod p == 1
        if g != 1 and pow(g, q, p) == 1:
            break

    print(f"Found generator g = {g} of order q={q}")
    return ElGamalParams(p=p, g=g)

def generate_elgamal_keys(params: ElGamalParams) -> Tuple[ElGamalPrivateKey, ElGamalPublicKey]:
    """Generates an ElGamal key pair (private x, public y) from given parameters.

    Args:
        params: The ElGamal parameters (p, g).

    Returns:
        A tuple containing the ElGamalPrivateKey and ElGamalPublicKey.
    """
    p, g = params.p, params.g
    q = (p - 1) // 2 # Order of the subgroup generated by g

    # 1. Choose a private key x
    #    x must be in the range [1, q-1]
    x = number.getRandomRange(1, q, randfunc=os.urandom) # Upper bound is exclusive for getRandomRange

    # 2. Calculate the public key y
    #    y = g^x mod p
    y = pow(g, x, p)

    private_key = ElGamalPrivateKey(params=params, x=x)
    public_key = ElGamalPublicKey(params=params, y=y)
    return private_key, public_key

def sign_message_elgamal(private_key: ElGamalPrivateKey, message: bytes) -> ElGamalSignature:
    """Signs a message using the ElGamal private key.

    Args:
        private_key: The ElGamalPrivateKey object.
        message: The message to sign (as bytes).

    Returns:
        An ElGamalSignature object containing (r, s).

    Raises:
        ValueError: If the message is empty.
    """
    if not message:
        raise ValueError("Message cannot be empty.")

    p, g = private_key.params.p, private_key.params.g
    x = private_key.x
    q = (p - 1) // 2 # Order of the subgroup

    # 1. Hash the message
    #    Use SHA-256. The output needs to be converted to an integer.
    h_obj = SHA256.new(message)
    # Corrected line:
    h = int.from_bytes(h_obj.digest(), byteorder='big')

    while True:
        # 2. Choose a random secret k
        #    k must be in the range [1, q-1].
        k = number.getRandomRange(1, q, randfunc=os.urandom)

        # 3. Calculate r = g^k mod p
        r = pow(g, k, p)
        # In the subgroup variant, r should also be taken mod q for the signature component.
        # However, standard ElGamal uses r = g^k mod p.
        # Let's stick to the standard definition first.
        # r = r % q # If using the DSA-like variant
        if r == 0:
            continue # Should not happen if p is prime and g != 0

        # 4. Calculate s = (h + x*r) * k^-1 mod q (Note: Some variants use h - xr)
        #    Let's use the variant s = k^-1 * (h - x*r) mod q, which is more common.
        #    Need to compute the modular inverse of k modulo q.
        try:
            k_inv = number.inverse(k, q)
        except ValueError: # Should not happen if q is prime and 1 <= k < q
            continue

        # Calculate s = (h - x*r) mod q * k_inv mod q
        term1 = h % q
        term2 = (x * r) % q
        s_unsigned = (term1 - term2 + q) % q # Add q to handle potential negative result
        s = (s_unsigned * k_inv) % q

        # r and s cannot be 0 in the standard ElGamal signature scheme.
        if s != 0 and r != 0:
            break

    return ElGamalSignature(r=r, s=s)

def verify_signature_elgamal(public_key: ElGamalPublicKey, message: bytes, signature: ElGamalSignature) -> bool:
    """Verifies an ElGamal signature.

    Args:
        public_key: The ElGamalPublicKey object.
        message: The original message (as bytes).
        signature: The ElGamalSignature object (r, s) to verify.

    Returns:
        True if the signature is valid, False otherwise.

    Raises:
        ValueError: If the message is empty or signature components are invalid.
    """
    if not message:
        raise ValueError("Message cannot be empty.")

    p, g = public_key.params.p, public_key.params.g
    y = public_key.y
    r, s = signature.r, signature.s
    q = (p - 1) // 2

    # 1. Check validity of r and s
    #    0 < r < p and 0 < s < q
    if not (0 < r < p and 0 < s < q):
        print(f"Signature validation failed: r or s out of range (r={r}, s={s}, p={p}, q={q})")
        return False

    # 2. Hash the message (must use the same hash function as signing)
    h_obj = SHA256.new(message)
    # Corrected line:
    h = int.from_bytes(h_obj.digest(), byteorder='big')
    # Hash doesn't need to be taken mod q here for the standard verification equation.

    # 3. Perform the verification check:
    #    Check if g^h == y^r * r^s (mod p)
    #    Calculate left side: v1 = g^h mod p
    #    Calculate right side: v2 = (y^r * r^s) mod p

    try:
        # Ensure calculations are done with sufficient precision (Python handles large integers)
        v1 = pow(g, h, p)
        v2_term1 = pow(y, r, p)
        v2_term2 = pow(r, s, p)
        v2 = (v2_term1 * v2_term2) % p

        # Compare
        is_valid = (v1 == v2)
        if not is_valid:
             print(f"Signature validation failed: Verification equation g^h = y^r * r^s (mod p) does not hold.")
             print(f"  g^h mod p = {v1}")
             print(f"  y^r * r^s mod p = {v2}")
        return is_valid

    except Exception as e:
        # Catch potential errors during modular exponentiation (e.g., invalid inputs)
        print(f"Error during verification calculation: {e}")
        return False

# --- Example Usage --- 
def run_elgamal_example():
    """Demonstrates the ElGamal signing and verification process."""
    print("\n--- ElGamal Signature Example ---")

    try:
        # 1. Parameter Generation (using a smaller key size for speed in example)
        print("Generating ElGamal parameters (1024 bits)...")
        # Use 1024 for example speed, recommend 2048+ for real use
        params = generate_elgamal_params(key_size=1024)
        print(f"Parameters: p={params.p}, g={params.g}")

        # 2. Key Generation
        print("\nGenerating ElGamal key pair...")
        private_key, public_key = generate_elgamal_keys(params)
        print(f"Private Key x: <hidden>") # Don't print private key
        print(f"Public Key y: {public_key.y}")

        # 3. Message Preparation
        message = b"This is the message to be signed using ElGamal."
        print(f"\nOriginal Message: {message.decode()}")

        # 4. Signing
        print("Signing the message...")
        signature = sign_message_elgamal(private_key, message)
        print(f"Generated Signature: r={signature.r}, s={signature.s}")

        # 5. Verification (Successful Case)
        print("\nVerifying the signature with the correct public key...")
        is_valid = verify_signature_elgamal(public_key, message, signature)
        print(f"Signature valid? {is_valid}")
        assert is_valid

        # 6. Verification (Tampered Message)
        print("\nVerifying the signature with a tampered message...")
        tampered_message = b"This message has been tampered with."
        is_valid_tampered = verify_signature_elgamal(public_key, tampered_message, signature)
        print(f"Signature valid for tampered message? {is_valid_tampered}")
        assert not is_valid_tampered

        # 7. Verification (Incorrect Key)
        print("\nGenerating a second key pair...")
        # Ensure the new key uses the same parameters p, g
        _, wrong_public_key = generate_elgamal_keys(params)
        print("Verifying the signature with an incorrect public key...")
        is_valid_wrong_key = verify_signature_elgamal(wrong_public_key, message, signature)
        print(f"Signature valid with wrong key? {is_valid_wrong_key}")
        assert not is_valid_wrong_key

        # 8. Verification (Invalid Signature component)
        print("\nVerifying with an invalid signature component (s=0)...")
        # Create signature with s=0, ensure r is valid first
        if signature.r > 0 and signature.r < public_key.params.p:
            invalid_signature = ElGamalSignature(r=signature.r, s=0)
            is_valid_invalid_sig = verify_signature_elgamal(public_key, message, invalid_signature)
            print(f"Signature valid with s=0? {is_valid_invalid_sig}")
            assert not is_valid_invalid_sig
        else:
            print("Skipping s=0 test as original r was invalid (should not happen).")

        print("\nElGamal example completed successfully.")

    except Exception as e:
        print(f"\nAn error occurred during the ElGamal example: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    # This block allows running the example directly
    run_elgamal_example()

